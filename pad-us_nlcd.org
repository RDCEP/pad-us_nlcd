#+TITLE:     Synthesis of a disaggregated carbon inventory for the conterminous United States
#+AUTHOR:    Neil Best, Joshua Elliott
#+EMAIL:     nbest@ci.uchicago.edu
#+DATE:      
#+DESCRIPTION: Where does the description appear?
#+KEYWORDS: woody biomass, land cover, protected areas
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME: 
#+XSLT:

#+PROPERTY: session *R*
#+PROPERTY: results silent

* Abstract

This technical paper describes and reveals the process of combining 
* DONE tangle out the R code and run it from the Makefile

This won't work until another function call is included to run the R code.


* initialize the session

#+NAME: init
#+BEGIN_SRC R :tangle tangled/init.R
## library( raster)
library( raster, lib.loc="~/src/R/lib/")
setOptions( progress= "text")
library( plyr)
library( stringr)
library( ascii)
options( asciiType= "org")

overwriteRasters <- TRUE

#+END_SRC


* COMMENT are these obsolete?
** process Puerto Rico to work out steps

#+NAME: grid
#+BEGIN_SRC R :tangle no :eval no
  
  pr <- raster( "nlcd2006/pr_landcover_wimperv_10-28-08_se5.img")
  NAvalue( pr) <- 0
  pr <- setMinMax( pr)
  
  prGrid <- try( raster( "prGrid.tif"), silent= TRUE)
  if( inherits( prGrid, "try-error") || overwriteRasters) {             
    prGrid <- raster( pr)
    prGrid[] <- seq( 1, ncell( prGrid))
    prGrid <-
      mask( prGrid, pr,
           filename= "prGrid.tif",
           overwrite= TRUE,
           progress= "text")
  }
  
  gridProjFunc <- function( cell) {
    cellFromXY( world,
               project( xyFromCell( prGrid, cell),
                       projection( prGrid),
                       inv= TRUE))
  }  
  
  prWorld <- try( raster( "world_5min_PuertoRico.tif"), silent= TRUE)
  if( inherits( prWorld, "try-error") || overwriteRasters) {             
    prWorld <-
      calc( prGrid, gridProjFunc,
           filename= "world_5min_PuertoRico.tif",
           datatype= "INT4U",
           overwrite= TRUE,
           progress= "text")
  }
  
  prGap <- raster( "pad-us/PADUS1_2_regions/PADUS1_2_PuertoRico_GAP.tif")
  prGap <- setMinMax( prGap)
  NAvalue( prGap) <- 255
    
  prGap <- overlay( prGap, prGrid, fun= setGapZero,
                   filename= "prGap.tif", datatype= "INT1U", progress= "text", overwrite= TRUE)
  NAvalue( prGap) <- 255
  
  
  prStack <- stack(prWorld, pr, prGap)
  layerNames( prStack) <- c( "grid", "nlcd", "gap")
  
  ct <- crosstab( prStack, useNA= "always", long= TRUE, responseName= "n", progress="text")
#+END_SRC

#+results:


* load NLCD rasters


#+NAME: regionPatterns
#+BEGIN_SRC R :results silent :tangle tangled/init.R
regionPatterns <-
  list(
    Nlcd01v1PR= "pr.*?img$",
    Nlcd01v1HI= "hi.*?img$",
    Nlcd01v1AK= "ak.*?img$",
    Nlcd01v1= "nlcd2001_mosaic_2-20-07.img$",
    Nlcd01v2= "nlcd2001_landcover_v2_2-13-11.img$",
    Nlcd06= "nlcd2006_landcover_4-20-11_se5.img$")

regions <-
  names( regionPatterns)
names( regions) <-
  names( regionPatterns)

nlcdRasters <-
  llply(
    regionPatterns,
    function( patt) {
      r <-
        raster(
          list.files(
            "nlcd",
            patt= patt,
            full.names= TRUE,
            recursive= TRUE))
      NAvalue( r) <- 0
      r
    })

#+END_SRC


* calculate 5' cell ID for each 30m pixel

Write out a 5' raster in geographic projection where the value of each
cell is its grid ID.  This will be reprojected into the cooridnate
space of each PAD-US/NLCD stack.

#+NAME: world  
#+BEGIN_SRC R :tangle tangled/init.R
  world <- raster()
  res( world) <- 5/60
  ## dataType( world) <- "INT4U"
  world[ ] <-
    1:ncell( world)
  world <-
    writeRaster(
      world, "data/grid5minWorld.tif",
      datatype= "INT4U",
      overwrite= overwriteRasters)
#+END_SRC

#+begin_src makefile :eval no :tangle tangled/pad-us_nlcd.mk
data/grid5minAeaCUSA.img: grid5minWorld.tif
	gdalwarp -overwrite -of HFA \
          -t_srs "+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs" \
          -te -2493045 177285 2342655 3310005 \
          -tr 30 30 -co "COMPRESSED=YES" $< $@

data/grid5minAeaAlaska.img: grid5minWorld.tif
	gdalwarp -overwrite -of HFA \
          -t_srs "+proj=aea +lat_1=55 +lat_2=65 +lat_0=50 +lon_0=-154 +x_0=0 +y_0=0 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs" 
          -te -2232345 344805 1494735 2380125 \
          -tr 30 30 -co "COMPRESSED=YES" $< $@

data/grid5minAeaPuertoRico.img: grid5minWorld.tif
	gdalwarp -overwrite -of HFA \
          -t_srs "+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs" \
          -te 3092415 -78975 3345225 59415 \
          -tr 30 30 -co "COMPRESSED=YES" $< $@

data/grid5minAeaHawaii.img: grid5minWorld.tif
	gdalwarp -overwrite -of HFA \
          -t_srs "+proj=aea +lat_1=8.000000000000002 +lat_2=18 +lat_0=3 +lon_0=-157 +x_0=0 +y_0=0 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs" \
          -te -345945 1753875 237225 2132415 \
          -tr 30 30 -co "COMPRESSED=YES" $< $@

grids: data/grid5minAeaCUSA.img \
       data/grid5minAeaAlaska.img \
       data/grid5minAeaPuertoRico.img \
       data/grid5minAeaHawaii.img

#+end_src


*** COMMENT DONE How did I write the gdalwarp command for the grid IDs?
I must have done it by hand.  This should be tangled out and called in
the Makefile.

*** TODO get overwriteRasters value from environment variable


** COMMENT add zeroes to GAP data for unprotected land and coastal areas

skip this. unnecessary.

#+BEGIN_SRC R :eval no
gapFiles <-
  list.files( "pad-us/data/",
             patt= "^PADUS1_2_.*?tif$",
             full.names= TRUE)
names( gapFiles) <-
  str_match( gapFiles,
            "PADUS1_2_([^_]+)_GAP\\.tif$")[, 2]

gapRasters <-
  llply( names( regionPatterns),
        function ( region) {
          r <- raster( gapFiles[[ region]])
          NAvalue( r) <- 255
          ## r <- setMinMax( r)
          layerNames( r) <- region
          r
        })
names( gapRasters) <- names( regionPatterns)

setGapZero <-
  function( gap, grid) {
    ifelse( is.na( gap) & !is.na( grid), 0, gap)
  }

gapOverlayFunc <-
  function ( gap, nlcd) {
    fn <- sprintf( "gap%s.grd", layerNames( gap))
    if( overwriteRasters | !file.exists( fn)) {
      overlay( gap, nlcd,
              fun= setGapZero,
              filename= fn,
              datatype= "INT1U",
              overwrite= TRUE)
    } else try( raster( fn), silent= TRUE)
  }

gapOverlays <-
  llply( regions,
        function( region) {
          gapOverlayFunc( gapRasters[[ region]],
                         nlcdRasters[[ region]])
        })

#+END_SRC

#+results:
   

** COMMENT create stacks and tabulate

This is too slow.  Had to do it in GRASS.
#+NAME: stacks
#+BEGIN_SRC R :eval no
aeaGridFunc <-
  function( region) {
    raster( sprintf( "aeaGrid5min%s.img", region))
  }

aeaGrids <- llply( regions, aeaGridFunc)

gapStackFunc <-
  function( region) {
    s <- stack( aeaGrids[[ region]],
               nlcdRasters[[ region]],
               gapOverlays[[ region]])
    layerNames( s) <- c( "grid", "nlcd", "gap")
    s
  }

gapStacks <- llply( regions, gapStackFunc)

writeCrosstabs <-
  function( region) {
    fn <- sprintf( "pad-us_nlcd_%s.csv", region)
    ct <- crosstab( gapStacks[[ region]])
    write.csv( ct, row.names= FALSE, file= fn)
    fn
  }

ctFiles <- llply( regions, writeCrosstabs)
#+END_SRC


* noweb componenets for GRASS scripts

** initialize a GRASS session

#+NAME: grassInit
#+begin_src sh :eval no
export GISBASE=/usr/lib/grass64
export PATH=$PATH:$GISBASE/bin:$GISBASE/scripts
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$GISBASE/lib

# use process ID (PID) as lock file number:
export GIS_LOCK=$$

# path to GRASS settings file
export GISRC=./.grassrc6
#+end_src

** create the GRASS location and import the reprojected grid

#+NAME: grassCreate
#+BEGIN_SRC sh :eval no
# path to GRASS binaries and libraries:
g.gisenv set=LOCATION_NAME=$GIS_LOCK
eval $(g.gisenv)
mkdir -p $GISDBASE/$GIS_LOCK
g.mapset -c mapset=temp
r.in.gdal in=aeaGrid5min${LOCATION}.img out=grid_5min location=${LOCATION}
g.mapset mapset=PERMANENT location=${LOCATION}
rm -rf $GISDBASE/$GIS_LOCK/temp
r.in.gdal input=pad-us/data/PADUS1_2_${LOCATION}_GAP.tif output=gap
#+END_SRC


** compose the r.in.gdal commands using the R data structures
#+NAME: rInGdalNlcd( region= "Nlcd01v1PR")
#+BEGIN_SRC R :results output verbatim replace 
path <-
  list.files(
    "nlcd",
    patt= regionPatterns[[ region]],
    full.names= TRUE,
    recursive= TRUE)

cat( sprintf( "r.in.gdal input=%s output=%s", path, region), "\n")
#+END_SRC

#+RESULTS: rInGdalNlcd
: r.in.gdal input=nlcd/pr_landcover_wimperv_10-28-08_se5.img output=Nlcd01v1PR


*** TODO add '-N' to r.stats for NLCD/GAP tabulation to eliminate *,*,*,n record created by the mask
    

** compose the r.stats commands for  the grid/NLCD/GAP tabulation

#+NAME: grassMapcalc
#+BEGIN_SRC sh :eval no
r.mapcalc MASK="if( ${NLCD} > 0, 1, null())"
echo grid_5min,${NLCD},gap,n > stats${NLCD}.csv
r.stats -c input=grid_5min,${NLCD},gap fs=, >> stats${NLCD}.csv
r.mask -r
echo grid_5min,n > grid${NLCD}.csv
r.stats -c input=grid_5min fs=, >> grid${NLCD}.csv
#+END_SRC


** clean up

#+NAME: grassCleanup
#+begin_src sh :eval no
# run GRASS' cleanup routine
$GISBASE/etc/clean_temp

# remove session tmp directory:
rm -rf /tmp/grass6-$USER-$GIS_LOCK
#+end_src


* compose and execute the GRASS scripts
    :PROPERTIES:
    :noweb:    yes
    :shebang:  #!/bin/bash -v
    :session:  nil
    :eval:     no
    :END:

#+NAME: grassPuertoRico
#+BEGIN_SRC sh :tangle tangled/grassPuertoRico.sh
LOCATION=PuertoRico
NLCD=Nlcd01v1PR
<<grassInit>>
<<grassCreate>>
<<rInGdalNlcd( "Nlcd01v1PR")>>
<<grassMapcalc>>
<<grassCleanup>>
#+END_SRC

#+NAME: grassHawaii
#+BEGIN_SRC sh :tangle tangled/grassHawaii.sh
LOCATION=Hawaii
NLCD=Nlcd01v1HI
<<grassInit>>
<<grassCreate>>
<<rInGdalNlcd( "Nlcd01v1HI")>>
<<grassMapcalc>>
<<grassCleanup>>
#+END_SRC

#+NAME: grassAlaska
#+BEGIN_SRC sh :tangle tangled/grassAlaska.sh
LOCATION=Alaska
NLCD=Nlcd01v1AK
<<grassInit>>
<<grassCreate>>
<<rInGdalNlcd( "Nlcd01v1AK")>>
<<grassMapcalc>>
<<grassCleanup>>
#+END_SRC

#+NAME: grassCUSA
#+BEGIN_SRC sh  :tangle tangled/grassCUSA.sh
LOCATION=cUSA
NLCD=Nlcd01v1
<<grassInit>>
<<grassCreate>>
<<rInGdalNlcd( "Nlcd01v1")>>
<<grassMapcalc>>
NLCD=Nlcd01v2
<<rInGdalNlcd( "Nlcd01v2")>>
<<grassMapcalc>>
NLCD=Nlcd06
<<rInGdalNlcd( "Nlcd06")>>
<<grassMapcalc>>
<<grassCleanup>>
#+END_SRC


* ingest the NBCD data and retabulate
    :PROPERTIES:
    :noweb:    yes
    :shebang:  #!/bin/bash -v
    :session:  nil
    :eval:     no
    :END:

#+NAME: grassNbcd
#+BEGIN_SRC sh :tangle tangled/grassNbcd.sh
<<grassInit>> #
g.gisenv set=LOCATION_NAME=cUSA
g.gisenv set=MAPSET=PERMANENT
eval $(g.gisenv)

export GRASS_MESSAGE_FORMAT=plain 
r.in.gdal --overwrite -e input=nbcd/data/nbcdAldb.vrt output=nbcdAldb
r.in.gdal --overwrite -e input=nbcd/data/nbcdBawh.vrt output=nbcdBawh
r.in.gdal --overwrite -e \
    input=nlcd/nlcd2001_canopy_mosaic_1-29-08/nlcd_canopy_mosaic_1-29-08.img \
    output=canopy
# r.in.gdal --overwrite input=cusaStatesAea.img output=states
# r.in.gdal --overwrite input=cusaCountiesAea.img output=counties
# r.in.gdal --overwrite input=nbcdZones.img output=zones

# g.region rast=nbcd
# r.mapcalc nbcdZero='if( isnull( nbcd), 0, nbcd)'

g.region rast=Nlcd01v1
r.mask -o input=Nlcd01v1 maskcats="1 thru 95"

r.mapcalc nbcdMask='eval( nbcd=canopy > 0 && nbcdBawh > 0, if( isnull( nbcd), 0, nbcd))'

# echo grid_5min,Nlcd01v1,gap,aldb,n > data/statsNbcdNlcd01v1Grid5min.csv && \
# r.stats -Nc input=grid_5min,Nlcd01v1,gap,nbcdAldb fs=, >> data/statsNbcdNlcd01v1Grid5min.csv 2> data/statsNbcdNlcd01v1Grid5min.err &

echo state,county,Nlcd01v1,gap,nbcd,aldb,n > data/statsNbcdNlcd01v1County.csv \
    && r.stats -Nc input=states,counties,,Nlcd01v1,gap,nbcdMask,nbcdAldb fs=, \
    >> data/statsNbcdNlcd01v1County.csv \
    2> data/statsNbcdNlcd01v1County.err &

# echo zone,Nlcd01v1,gap,aldb,n > data/statsNbcdNlcd01v1Zone.csv && \
# r.stats -Nc input=zones,Nlcd01v1,gap,nbcd fs=, >> data/statsNbcdNlcd01v1Zone.csv 2> data/statsNbcdNlcd01v1Zone.err &

# g.region rast=Nlcd01v2
# r.mask -o input=Nlcd01v2 maskcats="1 thru 95"

# echo grid_5min,Nlcd01v2,gap,nbcd,n > data/statsNbcdNlcd01v2Grid5min.csv && \
# r.stats -Nc input=grid_5min,Nlcd01v2,gap,nbcd fs=, >> data/statsNbcdNlcd01v2Grid5min.csv 2> data/statsNbcdNlcd01v2Grid5min.err &

# echo state,county,nlcd01v2,gap,nbcd,n > data/statsNbcdNlcd01v2County.csv && \
# r.stats -Nc input=states,counties,Nlcd01v2,gap,nbcd fs=, >> data/statsNbcdNlcd01v2County.csv 2> data/statsNbcdNlcd01v2County.err &

# echo zone,nlcd01v2,gap,nbcd,n > data/statsNbcdZone.csv && \
# r.stats -Nc input=zones,Nlcd01v2,gap,nbcd fs=, >> data/statsNbcdNlcd01v2Zone.csv 2> data/statsNbcdNlcd01v2Zone.err &

# g.region rast=Nlcd06
# r.mask -o input=Nlcd06 maskcats="1 thru 95"

# echo grid_5min,nlcd06,gap,nbcd,n > data/statsNbcdNlcd06Grid5min.csv && \
# r.stats -Nc input=grid_5min,Nlcd06,gap,nbcd fs=, >> data/statsNbcdNlcd06Grid5min.csv 2> data/statsNbcdNlcd06Grid5min.err &

# echo state,county,nlcd06,gap,nbcd,n > data/statsNbcdNlcd06County.csv && \
# r.stats -Nc input=states,counties,Nlcd06,gap,nbcd fs=, >> data/statsNbcdNlcd06County.csv 2> data/statsNbcdNlcd06County.err &

# echo zone,nlcd06,gap,nbcd,n > data/statsNbcdNlcd06Zone.csv && \
# r.stats -Nc input=zones,Nlcd06,gap,nbcd fs=, >> data/statsNbcdNlcd06Zone.csv 2> data/statsNbcdNlcd06Zone.err &

r.mask -r
<<grassCleanup>>

#+END_SRC

** TODO separate the import of the political units' rasters


** TODO decide whether or not to throw out the other NLCD results


* aggregate the PAD-US results
   :PROPERTIES:
   :eval:     no
   :END:

#+NAME: writeFracsProto
#+begin_src R :eval no
  library( reshape)
  library( Hmisc)
  
  cells <-
    read.csv( "gridPuertoRico.csv",
             col.names= c( "cell", "n"))
  
  stats <-
    read.csv( "statsPuertoRico.csv",
             na.strings= "*",
             col.names= c( "cell", "nlcd", "gap", "n"),
             colClasses= c("numeric", "factor", "factor", "numeric"))
  ## won't need this when r.stats in previous GRASS step is fixed
  stats <- stats[ !is.na(stats$cell),]
  
  ## stats <- stats[ !is.na(stats$grid),]
  ## stats <- stats[ stats$cell != "*",]
  
  ## stats <- within( stats, gap[ is.na( gap)] <- 0)
  
  
  stats <-
    within( stats,
           { levels( gap) <- c( levels( gap), "0")
             gap[ is.na( gap)] <- "0"
             gap <- combine_factor( gap, c(0,1,1,1,0))
             levels( gap) <- c( "no", "yes")
           })
  
  stats <-
    cast( data= stats,
         formula= cell ~ gap + nlcd,
         fun.aggregate= sum,
         margins= "grand_col",
         value= "n" )
  colnames( stats)[ colnames( stats) == "(all)_(all)"] <- "nlcd"
  
  merged <-
    within( merge( stats, cells, by= "cell", all.x= TRUE),
           no_11 <- no_11 + n - nlcd)
  
  fracs <-
    cast( within( melt( merged,
                       c( "cell", "n")),
                 value <- value / n),
         formula= cell ~ variable,
         subset= variable != "nlcd",
         margins= "grand_col",
         fun.aggregate= sum)
  
  write.csv( format.df( fracs,
                       dec= 3,
                       numeric.dollar= FALSE,
                       na.blank= TRUE),
            row.names= FALSE,
            file= "fracsPuertoRico.csv",
            quote= FALSE)
#+END_SRC
  
#+NAME: writeFracs
#+begin_src R 
  library( reshape)
  library( Hmisc)

  writeFracs <- function( region) {
    cells <-
      read.csv( sprintf( "grid%s.csv", region),
               col.names= c( "cell", "n"))
    stats <-
      read.csv( sprintf( "stats%s.csv", region),
               na.strings= "*",
               col.names= c( "cell", "nlcd", "gap", "n"),
               colClasses= c("numeric", "factor", "factor", "numeric"))
    ## won't need this when r.stats in previous GRASS step is fixed
    stats <- stats[ !is.na(stats$cell),]
    stats <-
      within( stats,
             { levels( gap) <- c( levels( gap), "0")
               gap[ is.na( gap)] <- "0"
               gap <- combine_factor( gap, c(0,1,1,1,0))
               levels( gap) <- c( "no", "yes")
             })
    stats <-
      cast( data= stats,
           formula= cell ~ gap + nlcd,
           fun.aggregate= sum,
           margins= "grand_col",
           value= "n" )
    colnames( stats)[ colnames( stats) == "(all)_(all)"] <- "nlcd"
    merged <-
      within( merge( stats, cells, by= "cell", all.x= TRUE),
             no_11 <- no_11 + n - nlcd)
    fracs <-
      cast( within( melt( merged,
                         c( "cell", "n")),
                   value <- value / n),
           formula= cell ~ variable,
           subset= variable != "nlcd",
           margins= "grand_col",
           fun.aggregate= sum)
    fn <- sprintf( "fracs%s.csv", region)
    write.csv( format.df( fracs,
                         dec= 3,
                         numeric.dollar= FALSE,
                         na.blank= TRUE),
              row.names= FALSE,
              file= fn,
              quote= FALSE)
    fn
  }
  
  regions <- c( "PuertoRico", "Hawaii", "Alaska", "cUSA")
  names( regions) <- regions
  
  fracFiles <- llply( regions, writeFracs)
  
  zip( "pad-us_nlcd.zip", list.files( patt= "^fracs.*?\\csv$"))
#+end_src
   

** TODO do this with data.table

   
* generate NBCD statistics
  :PROPERTIES:
  :eval:     yes
  :END:


** by 5' grid cells

#+NAME: writeNbcdStats
#+begin_src R 
  library( reshape)
  library( Hmisc)
  library( data.table)

  stats <-
    read.csv( "statsNbcd.csv",
             na.strings= "*",
             col.names= c( "cell", "nlcd", "gap", "nbcd", "n"),
             colClasses= c("numeric", "factor", "factor", "numeric"))
  
  stats <-
    within(
      stats,
      { levels( gap) <- c( levels( gap), "0")
        gap[ is.na( gap)] <- "0"
        gap <- combine_factor( gap, c(0,1,1,1,0))
        levels( gap) <- c( "no", "yes")
        nbcd[ is.na( nbcd)] <- 0
      })
  
  dt <- data.table( stats)
  setkey( dt, cell, nlcd, gap)
  
  wm <- dt[, list( wm= weighted.mean( nbcd, n)), by= "cell,nlcd,gap"]
  
  wmCt <-
    cast(
      data= wm,
      formula= cell ~ gap + nlcd,
      ## fun.aggregate= sum,
      ## margins= "grand_col",
      value= "wm" )
  
  write.csv(
    format.df(
      wmCt,
      cdec= c( 0, rep( 1, ncol( wmCt) - 1)),
      numeric.dollar= FALSE,
      na.blank= TRUE),
    row.names= FALSE,
    file= "nbcdFiaAldb.csv",
    quote= FALSE)
  
  zip( "pad-us_nlcd_nbcd.zip", "fracscUSA.csv")
  zip( "pad-us_nlcd_nbcd.zip", "nbcdFiaAldb.csv")
  
#+end_src
  

** TODO convert NAs to zeros for \*Fr and \*Ha in CSVs and SHPs
** TODO trim spaces in char data frames before writing CSVs


** load r.stats output

#+begin_src R

library( reshape)
library( Hmisc)
library( data.table)
library( stringr)
library( ggplot2)
library( foreign)

stateAttrs <-
  read.dbf( "shp/tl_2010_us_state10.dbf")
stateNames <-
  data.table( stateAttrs[, c( "STATEFP10", "STUSPS10", "NAME10")])
setnames(
  stateNames,
  names( stateNames),
  c( "state", "usps", "name"))
setkey( stateNames, state)

keycols <- c(
  "state", "county", "nlcd", 
  "gap",  "nbcd", "aldb")

rawCountyStats <-
  read.csv(
    "data/statsNbcdNlcd01v1County.csv",
    na.strings= "*",
    header= TRUE,
    col.names= c( keycols, "n"),
    colClasses= c(
      "character", "character", "character",
      "integer", "integer", "integer", "integer"))

rawCountyStats <- data.table( rawCountyStats)
setkeyv( rawCountyStats, keycols)

{
  rawCountyStats[ is.na(  state),  state := "0"]
  rawCountyStats[ is.na( county), county := "0"]
  rawCountyStats[,  state :=
                 str_pad(
                   as.character(  state),
                   2, pad= "0")]
  rawCountyStats[, county :=
                 str_pad(
                   as.character( county),
                   3, pad= "0")]
  rawCountyStats[ is.na( gap), gap := 0L]
  rawCountyStats[ gap == 4L, gap := 0L]
  rawCountyStats[ gap != 0L, gap := 1L]
  rawCountyStats[ is.na( aldb), aldb := 0L]
  rawCountyStats[, gap := as.logical( gap)]
  rawCountyStats[, nbcd := as.logical( nbcd)]
  rawCountyStats[ !nbcd, aldb := NA]
}

setkeyv( rawCountyStats, keycols)


#+end_src

** collapse the records for GAP values that are no longer differentiated


#+begin_src R

rawCountyStats <-
  rawCountyStats[, list( n= sum( n)),
                 keyby= keycols ]

rawStateStats <- 
  rawCountyStats[, list( n= sum( n)),
                 keyby= keycols[ -2] ]


## same thing in functional form

## rawStateStats <- `[`(
##   x= rawCountyStats,
##   j= list( n= sum( n)),
##   keyby= keycols[ -2])

#+end_src

Show the low-density forests that we intend to backfill.


#+NAME: forestHist
#+BEGIN_SRC R :results output graphics :exports both :results replace :file pad-us_nlcd/images/forestHist.png

qplot(
  data= rawCountyStats[ nlcd %in% as.character( c(41:43, 90))],
  x= aldb,
  weight= n,
  binwidth= 5,
  xlim= c( 0, 200),
  geom= "histogram", 
  group= gap,
  fill= gap,
  position= "dodge",
  ## position= "stack",
  facets= nlcd ~ .)

#+END_SRC

#+results: forestHist
[[file:pad-us_nlcd/images/forestHist.png]]


#+NAME: forestHistDetail
#+BEGIN_SRC R :results output graphics :exports both :results replace :file pad-us_nlcd/images/forestHistDetail.png

qplot(
  data= rawCountyStats[ nlcd %in% as.character( c(41:43, 90))],
  x= aldb,
  weight= n,
  binwidth= 1,
  xlim= c( 0, 20),
  geom= "histogram", 
  group= gap,
  fill= gap,
  position= "dodge",
  ## position= "stack",
  facets= nlcd ~ .)

#+END_SRC

#+results: forestHistDetail
[[file:pad-us_nlcd/images/forestHistDetail.png]]

** COMMENT by NBCD mapping zones
   :PROPERTIES:
   :eval:     no
   :END:
  
#+begin_src R
  library( reshape)
  library( Hmisc)
  library( data.table)
  library( stringr)
  
  ## define aggregateNbcd()
  
  ## statsNbcdZone <-
  ##   aggregateNbcd(
  ##     "statsNbcdZone.csv",
  ##     col.names= c(
  ##       "zone", "nlcd", "gap",
  ##       "aldb", "n"),
  ##     colClasses= c(
  ##       "character", "character", "factor",
  ##       "numeric", "numeric"))
  
  rawZoneStats <-
    read.csv(
      "csv/statsNbcdNlcd01v1Zone.csv",
      na.strings= "*",
      header= TRUE,
      col.names= c(
        "zone", "nlcd", 
        "gap", "aldb", "n"),
      colClasses= c(
        "character", "character",
        "numeric", "numeric", "numeric"))
  
  rawZoneStats <-
    within( rawZoneStats, {
      state[  is.na(  state)] <- 0   
      zone[ is.na( zone)] <- 0    
      gap[ is.na( gap)] <- 0
      gap[ gap == 4] <- 0
      gap[ gap !=0] <- 1
      aldb[ is.na( aldb)] <- 0
      gap <- as.logical( gap) } )
  
  rawCountyStats <- data.table( rawCountyStats)
  keycols <-
    colnames(rawCountyStats)[ colnames(rawCountyStats) != "n"]
  setkeyv( rawCountyStats, keycols)
  rawCountyStats <-
    rawCountyStats[, list( n= sum( n),
                          n2 = sum( replace( n, aldb <= 5, 0))),
       keyby= keycols ]
  
  zoneAreas <-
    statsNbcdZone[, list( totHa= sum(ha)),
                  by= "zone"]
  statsNbcdZone <-
    statsNbcdZone[ zoneAreas][, frac:=ha/totHa]
  
  nbcdZoneAldb <- 
      data.table(
        cast(
          data= statsNbcdZone,
          formula= zone ~ gap + nlcd,
          value= "aldb",
          subset= !is.na( aldb)),
        key= "zone")
  
  setnames(
    nbcdZoneAldb,
    colnames(nbcdZoneAldb),
    str_replace( colnames(nbcdZoneAldb), "_", ""))
  
  nbcdZoneAldbMeans <- 
    data.table(
      cast(
        data=
        statsNbcdZone[, list( aldbAve= weighted.mean( aldb, ha)),
                 by= c( "zone", "gap")],
        formula= zone ~ gap,
        value= "aldbAve",
        subset= !is.na( aldbAve)),
      key= "zone")
  
  setnames(
    nbcdCountyAldbMeans,
    colnames( nbcdCountyAldbMeans)[ -1],
    sprintf(
      "%sAll",
      colnames( nbcdCountyAldbMeans)[ -1]))
  
  nbcdZoneGapFrac <-
    data.table(
      cast(
        data= statsNbcdZone,
        formula= zone ~ gap,
        value= "frac",
        fun.aggregate= sum,
        subset= !is.na( aldb)),
      key= "zone")
  
  setnames(
    nbcdZoneGapFrac,
    colnames( nbcdZoneGapFrac)[ -1],
    sprintf(
      "%sAllFr",
      str_replace(
        colnames( nbcdZoneGapFrac)[ -1],
        "_", "")))
  
  nbcdZoneGapHa <-
    data.table(
      cast(
        data= statsNbcdZone,
        formula= zone ~ gap,
        value= "ha",
        fun.aggregate= sum,
        subset= !is.na( aldb)),
      key= "zone")
  
  setnames(
    nbcdZoneGapHa,
    colnames( nbcdZoneGapHa)[ -1],
    sprintf(
      "%sAllHa",
      str_replace(
        colnames( nbcdZoneGapHa)[ -1],
        "_", "")))
  
   nbcdZoneFrac <- 
    data.table(
      cast(
        data= statsNbcdZone,
        formula= zone ~ gap + nlcd,
        value= "frac",
        subset= !is.na( aldb)),
      key= "zone")
  
  setnames(
    nbcdZoneFrac,
    colnames( nbcdZoneFrac)[ -1],
    sprintf(
      "%sFr",
      str_replace(
        colnames( nbcdZoneFrac)[ -1],
        "_", "")))
  
  nbcdZoneHa <- 
    data.table(
      cast(
        data= statsNbcdZone,
        formula= zone ~ gap + nlcd,
        value= "ha",
        subset= !is.na( aldb)),
      key= "zone")
  
  setnames(
    nbcdZoneHa,
    colnames( nbcdZoneHa)[ -1],
    sprintf(
      "%sHa",
      str_replace(
        colnames( nbcdZoneHa)[ -1],
        "_", "")))
   
  nbcdZone <- nbcdZoneAldb[ nbcdZoneAldbMeans]
  nbcdZone <- nbcdZone[ nbcdZoneGapFrac][ nbcdZoneGapHa]
  nbcdZone <- nbcdZone[ nbcdZoneFrac][ nbcdZoneHa]
  setcolorder(
    nbcdZone,
    c( 1,
      order( colnames( nbcdZone)[ -1]) +1))
  
  nbcdZoneChar <-
    str_trim(
      format.df(
        nbcdZone,
        cdec= sapply(
          colnames( nbcdZone),
          function( x)
          ifelse(
            x == "zone", 0,
            ifelse(
              str_detect( x, "Ha$"), 1,
              ifelse(
                str_detect( x, "Fr$"), 3,
                1)))),
        numeric.dollar= FALSE,
        na.blank= TRUE))
  
  write.csv(
    nbcdZoneChar,
    row.names= FALSE,
    file= "nbcdZone.csv",
    quote= FALSE)
  
  zip( "pad-us_nlcd_nbcd.zip", "nbcdZone.csv")
   
  options(useFancyQuotes = FALSE)
   cat(
     sapply(
       colnames( nbcdZone),
       function( x) {
         dQuote(
           ifelse(
             x == "zone", "String(3)",
             ifelse(
               str_detect( x, "Ha$"),
               "Real(10.1)",
               ifelse(
                 str_detect( x, "Fr$"),
                 "Real(5.3)",
                 "Real(5.1)"))))
       }),
     sep= ",",
     file= "nbcdZone.csvt")
  
  ogr2ogr <-
    paste(
      "ogr2ogr -overwrite -progress -sql",
      sprintf(
        "\"select %s from nbcdZones a",
        paste( colnames( nbcdZone), collapse= ",")),
      "left join 'nbcdZone.csv'.nbcdZone b",
      "on a.zone = b.zone\"",
      "data/nbcdZone.shp data/nbcdZones.shp")
  
  system( ogr2ogr)
  
  zip(
    "pad-us_nlcd.zip",
    list.files(
      path= "pad-us_nlcd",
      pattern= "^nbcdZone\\.",
      full.names= TRUE))
  
  
#+end_src

*** TODO finish updating zone stat procedure to match state/county

GAP TRUE/FALSE naming, . . .


*** TODO figure out where null values in NBCD are coming from


** repeat for states

*** calculate the average densities for original and modified pixel counts

**** TODO Figure out how to do self-join in functional form

#+begin_src R
  
  statsNbcdState <- `[`(
    x= rawStateStats,
    j= list(
      aldb= weighted.mean( aldb, n),
      n= sum( n),
      ha= sum(n) * 30^2 / 10^4),
    keyby= "state,nlcd,gap,nbcd")
  
  stateAreas <- `[`(
    x= statsNbcdState ,
    j= list( totHa= sum(ha)),
    keyby= "state")
  
  statsNbcdState <-
    statsNbcdState[ stateAreas][, frac:= ha / totHa][, totHa := NULL]
  
  
  ## statsNbcdState <- `[`(
  ##   x= `[`(
  ##     x= statsNbcdState,
  ##     j= list( stateAreas)) ,
  ##   j= frac:= ha / totHa)
  
  ## `[`( x= statsNbcdState, j= stateAreas)
  
  ## `[`( x= statsNbcdState,
  ##     j= list(
  ##       names( statsNbcdState),
  ##       frac= ha / sum( .SD[, ha])),
  ##     keyby= "state")
#+end_src


To backfill those NLCD/GAP combinations we must calculate national averages.

#+BEGIN_SRC R :results output org replace :exports both
nbcdMean <-
  statsNbcdState[ n != n2][, list(
                    aldb= weighted.mean( aldb2, n, na.rm= TRUE)),
                    keyby= "nlcd,gap"]

ascii(
  cast(
    nbcdMean,
    nlcd ~ gap,
    value= "aldb"),
  digits = 1,
  include.rownames= FALSE)
#+END_SRC

#+results:
#+BEGIN_ORG
| nlcd | FALSE | TRUE  |
|------+-------+-------|
| 41   | 111.4 | 119.5 |
| 42   | 103.7 | 120.5 |
| 43   | 110.2 | 134.0 |
| 90   | 96.4  | 91.1  |
#+END_ORG


*** COMMENT these plots show states with problem forests

#+begin_src R :eval no

ggplot(
  statsNbcdState[ n != n2][ stateNames, nomatch= 0],
  aes(    x= n2/n,
          y= ha, ## aldb/aldb2,
      label= usps)) +
  geom_point() +
  geom_text(
    hjust= 0,
    vjust= 0) +
  facet_grid( nlcd ~ gap) +
  scale_y_log10() +
  scale_x_continuous( limits= c( 0.0, 0.8))


ggplot(
  statsNbcdState[ n != n2],
  aes(    x= n2/n,
          y= frac,
      label= state)) +
  geom_point() +
  geom_text(
    hjust= 0,
    vjust= 0) +
  facet_grid( nlcd ~ gap) +
  scale_y_log10()+
  scale_x_continuous( limits= c( 0.0, 0.8))

ggplot(
  statsNbcdState[ n != n2],
  aes(
    x= n2/n,
    y= aldb/aldb2,
    label= state)) +
  geom_point(
    aes(
      size= frac)) +
  geom_text(
    hjust= 1.0,
    vjust= 0) +
  facet_grid( nlcd ~ gap) +
  scale_x_continuous( limits= c( 0.0, 0.8)) +
  scale_size(
    limits= c(0.0, 0.3),
    range= c( 5, 15))

ggplot(
  statsNbcdState[ n != n2],
  aes(
    x= n2/n,
    y= frac,
    label= state)) +
  geom_point(
    aes(
      size= aldb/aldb2)) +
  geom_text(
    hjust= 1.0,
    vjust= 0) +
  facet_grid( nlcd ~ gap) +
  scale_y_log10()+
  scale_x_continuous( limits= c( 0.0, 0.8))



#+end_src


*** COMMENT backfill the null state densities with national means

#+begin_src R :eval no
## statsNbcdState <-
##   merge( statsNbcdState, nbcdMean, all.x= TRUE)
## statsNbcdState[ is.na( aldb2), aldb2 := aldb.y][, aldb.y := NULL]
## setkey( statsNbcdState, state, nlcd, gap)
## setnames( statsNbcdState, "aldb.x", "aldb")
## setcolorder( statsNbcdState, c( 3, 1, 2, 4:11))

## test
## any( abs( statsNbcdState[, list( frac= sum(frac)), by= state][, frac] - 1) > 0.001)

#+end_src


*** calculate the grand total

#+begin_src R
  statsNbcdState[ I( nbcd), list( Gt= sum( aldb * ha) / 10^9)]
#+end_src


*** write out the state data in long form

#+begin_src R

write.csv(
  statsNbcdState[, list( state,nlcd,gap,nbcd,aldb,n,ha,frac)],
  row.names= FALSE,
  file= "pad-us_nlcd/nbcdStateSerial.csv",
  quote= FALSE)

zip( "pad-us_nlcd.zip", "pad-us_nlcd/nbcdStateSerial.csv")

#+end_src



*** cross-tabulate the state data using backfilled densities


#+begin_src R
  
  nbcdStateAldb <- 
    data.table(
      cast(
        data= statsNbcdState,
        subset= nbcd,
        formula= state ~ gap + nlcd,
        value= "aldb"),
      key= "state")
  
  setnames(
    nbcdStateAldb,
    colnames( nbcdStateAldb),
    str_replace(
      str_replace(
        colnames(nbcdStateAldb),
        "TRUE_", "yes"),
      "FALSE_", "no"))
  
  
  nbcdStateAldbMeans <- 
    data.table(
      cast(
        data=
        statsNbcdState[
          I( nbcd),
          list( aldbAve= weighted.mean( aldb, ha)),
          by= c( "state", "gap")],
        formula= state ~ gap,
        value= "aldbAve"),
      key= "state")
  
  setnames(
    nbcdStateAldbMeans,
    c( "FALSE", "TRUE"),
    c( "noAll", "yesAll"))
  
  nbcdStateGapFrac <-
    data.table(
      cast(
        data= statsNbcdState,
        formula= state ~ gap,
        value= "frac",
        fun.aggregate= sum,
        na.rm = TRUE),
      key= "state")
  
  setnames(
    nbcdStateGapFrac,
    c( "FALSE", "TRUE"),
    c( "noAllFr", "yesAllFr"))
  
  nbcdStateGapHa <-
    data.table(
      cast(
        data= statsNbcdState,
        formula= state ~ gap,
        value= "ha",
        fun.aggregate= sum,
        na.rm= TRUE),
      key= "state")
  
  setnames(
    nbcdStateGapHa,
    c( "FALSE", "TRUE"),
    c( "noAllHa", "yesAllHa"))
  
  nbcdStateGapHa <-
    data.table(
      cast(
        data= statsNbcdState[, list( ha=sum( ha)),
          keyby= "state,gap,nbcd"],
        formula= state ~ gap + nbcd,
        value= "ha"),
      key= "state")
  
  setnames(
    nbcdStateGapHa,
    c( "FALSE_FALSE", "FALSE_TRUE", "TRUE_FALSE", "TRUE_TRUE"),
    c( "noAllHaN", "noAllHa", "yesAllHaN", "yesAllHa"))
  
  nbcdStateFrac <- 
    data.table(
      cast(
        data= statsNbcdState,
        subset= nbcd,
        formula= state ~ gap + nlcd,
        value= "frac"),
      key= "state")
  
  setnames(
    nbcdStateFrac,
    colnames( nbcdStateFrac)[ -1],
    paste(
      str_replace(
        str_replace(
          colnames( nbcdStateFrac)[ -1],
          "TRUE_", "yes"),
        "FALSE_", "no"),
      "Fr", sep= ""))
  
  nbcdNullStateFrac <- 
    data.table(
      cast(
        data= statsNbcdState,
        subset= !nbcd,
        formula= state ~ gap + nlcd,
        value= "frac"),
      key= "state")
  
  setnames(
    nbcdNullStateFrac,
    colnames( nbcdNullStateFrac)[ -1],
    paste(
      str_replace(
        str_replace(
          colnames( nbcdNullStateFrac)[ -1],
          "TRUE_", "yes"),
        "FALSE_", "no"),
      "FrN", sep= ""))
  
  nbcdStateHa <- 
    data.table(
      cast(
        data= statsNbcdState,
        subset= nbcd,
        formula= state ~ gap + nlcd,
        value= "ha"),
      key= "state")
  
  setnames(
    nbcdStateHa,
    colnames( nbcdStateHa)[ -1],
    paste(
      str_replace(
        str_replace(
          colnames( nbcdStateHa)[ -1],
          "TRUE_", "yes"),
        "FALSE_", "no"),
      "Ha", sep= ""))
  
  nbcdNullStateHa <- 
    data.table(
      cast(
        data= statsNbcdState,
        subset= !nbcd,
        formula= state ~ gap + nlcd,
        value= "ha"),
      key= "state")
  
  setnames(
    nbcdNullStateHa,
    colnames( nbcdNullStateHa)[ -1],
    paste(
      str_replace(
        str_replace(
          colnames( nbcdNullStateHa)[ -1],
          "TRUE_", "yes"),
        "FALSE_", "no"),
      "HaN", sep= ""))
  
  nbcdState <-
    nbcdStateAldb[ nbcdStateAldbMeans]
  nbcdState <-
    nbcdState[ nbcdStateGapFrac][ nbcdStateGapHa]
  nbcdState <-
    nbcdState[ nbcdStateFrac][ nbcdStateHa]
  nbcdState <-
    nbcdState[ nbcdNullStateFrac][ nbcdNullStateHa]
  
  setnames(
    nbcdState,
    "state", "fips")
  
  setcolorder(
    nbcdState,
    order( colnames( nbcdState)))
  
  nbcdStateChar <-
    str_trim(
      format.df(
        nbcdState,
        cdec= sapply(
          colnames( nbcdState),
          function( x) {
            ifelse(
              x == "fips", 0,
              ifelse(
                str_detect( x, "HaN?$"), 1,
                ifelse(
                  str_detect( x, "FrN?$"), 3,
                  1)))
          }),
        numeric.dollar= FALSE,
        na.blank= TRUE))
  
  write.csv(
    nbcdStateChar,
    row.names= FALSE,
    file= "pad-us_nlcd/nbcdState.csv",
    quote= FALSE)
  
  zip( "pad-us_nlcd.zip", "pad-us_nlcd/nbcdState.csv")
  
  options(useFancyQuotes = FALSE)
  cat(
    sapply(
      colnames( nbcdState),
      function( x) {
        dQuote(
          ifelse(
            x == "fips", "String(2)",
            ifelse(
              str_detect( x, "HaN?$"),
              "Real(10.1)",
              ifelse(
                str_detect( x, "FrN?$"),
                "Real(5.3)",
                "Real(5.1)"))))
      }),
    sep= ",",
    file= "pad-us_nlcd/nbcdState.csvt")
  options(useFancyQuotes = TRUE)
  
  ogr2ogr <-
    paste(
      "ogr2ogr -overwrite -progress -sql",
      sprintf(
        "\"select %s from cusaStatesAea a",
        paste( colnames( nbcdState), collapse= ",")),
      "left join 'pad-us_nlcd/nbcdState.csv'.nbcdState b",
      "on a.GEOID10 = b.fips\"",
      "pad-us_nlcd/nbcdState.shp shp/cusaStatesAea.shp")
  
  system( ogr2ogr)
  
  zip(
    "pad-us_nlcd.zip",
    list.files(
      path= "pad-us_nlcd",
      pattern= "^nbcdState\\.[a-z]{3}",
      full.names= TRUE))
#+end_src


*** COMMENT DONE figure out if is.na( aldb2) is correct

    

** repeat for counties

#+begin_src R
  ## library( reshape)
  ## library( Hmisc)
  ## library( data.table)
  ## library( stringr)
  
  statsNbcdCounty <-
    rawCountyStats[, list(
      aldb= weighted.mean( aldb, n),
      n= sum( n),
      ha= sum(n) * 30^2 / 10^4),
                   keyby= "state,county,nlcd,gap,nbcd"]
  countyAreas <-
    statsNbcdCounty[, list( totHa= sum(ha)),
                    keyby= c( "state", "county")]
  statsNbcdCounty <-
    statsNbcdCounty[ countyAreas][, frac:=ha/totHa]
    
  ## statsNbcdCounty <-
  ##   merge(
  ##     statsNbcdCounty,
  ##     statsNbcdState[, list( state, nlcd, gap, aldb2, n2)],
  ##     by= c( "state", "nlcd", "gap"),
  ##     all.x= TRUE)
  
  ## statsNbcdCounty[, fill := as.character(NA)]
  
  ## statsNbcdCounty[ n2.x == 0 & n2.y == 0, fill := "cUSA"]
  ## statsNbcdCounty[ n2.x == 0 & n2.y != 0, fill := "state"]
  
  ## statsNbcdCounty[ is.na( aldb2.x), aldb2.x := aldb2.y]
  ## statsNbcdCounty[, aldb2.y := NULL]
  ## statsNbcdCounty[,    n2.y := NULL]
  ## statsNbcdCounty[,   totHa := NULL]
  
  ## setkey( statsNbcdCounty, state, county, nlcd, gap)
  ## setnames(
  ##   statsNbcdCounty,
  ##   c( "aldb2.x", "n2.x"),
  ##   c( "aldb2",   "n2"))
  
  ## setcolorder(
  ##   statsNbcdCounty,
  ##   c( "state", "county", "nlcd", "gap",
  ##     "aldb", "aldb2", "n", "n2", "ha", "ha2",
  ##     "frac", "fill"))
  
  ## test
  ## any( abs( statsNbcdCounty[, list( frac= sum(frac)), by= "state,county"][, frac] - 1) > 0.001)
#+end_src

*** check for cases where NBCD makes no prediction

NBCD only predicts biomass density where it has sufficient canopy
density and basal area-weighted height to do so.  We can presume that
the ALDB density for a given state/county//nlcd/gap combination outside of the
NBCD prediction is something less than its modeled counterpart.  Any
heuristic that attempts to plug in a density value not predicted by
NBCD will fail when the NBCD prediction area was zero for a given
state/nlcd/gap combination.

#+BEGIN_SRC R :results output org replace :exports both
countyAreaCheck <- 
  data.table( cast(
    statsNbcdCounty,
    state + county + nlcd + gap ~ nbcd,
    value= "n"))

countyAreaCheck <-
  countyAreaCheck[ `FALSE` > 0 & `TRUE` == 0]
setkey( countyAreaCheck, state, county, nlcd, gap)


statsNbcdCountyTrue <- statsNbcdCounty[ I( nbcd)][, nbcd := NULL]
setkey( statsNbcdCountyTrue, state, county, nlcd, gap)

statsNbcdCountyFalse <- statsNbcdCounty[ !nbcd][, nbcd := NULL]
setkey( statsNbcdCountyFalse, state, county, nlcd, gap)

statsNbcdCountyTrue[ statsNbcdCountyFalse][ is.na( aldb)]

cast(
  data.frame(
    statsNbcdCounty[ !nbcd]),
    ## statsNbcdCountyTrue[ statsNbcdCountyFalse][ is.na( aldb)]),
  nlcd ~ gap,
  value= "ha",
  fun= sum,
  margins= TRUE)


aldbIgnoringGap <-
  statsNbcdCounty[ I( nbcd),
                  list(
                    aldb= weighted.mean(
                      aldb, n, na.rm= TRUE)),
                  keyby= "state,county,nlcd"]


cast(
  data.frame(
    ),
  nlcd ~ gap,
  value= "ha.1",
  fun= sum,
  margins= TRUE)


cast(
  data.frame(
    statsNbcdCounty),
  nlcd ~ gap,
  value= "ha",
  fun= sum,
  margins= TRUE)


statsNbcdCounty[ !nbcd, ha,
  keyby= "state,county,nlcd,gap"][
    statsNbcdCounty[, ha,
      keyby= "state,county,nlcd,gap"],
    nomatch=0][,
      list( haFalse= sum( ha),
           haTotal= sum( ha.1)), by="nlcd,gap"]

notModeledByNbcd <- 
  statsNbcdCounty[ !nbcd, ha, keyby= "state,county,nlcd,gap"][
    statsNbcdCounty[ , list( totHa= sum(ha)), keyby= "state,county,nlcd,gap"], nomatch=0][,
      list( ha= sum(ha), totHa= sum( totHa)), keyby= "nlcd,gap"]


notModeledPcts <- 
  data.frame(
    notModeledByNbcd[,
      pct := ha / totHa * 100])

within( notModeledPcts, {
  nlcd <- factor(nlcd, levels= names( nlcdCovers), labels= nlcdCovers)
}
                                         
ascii(
  cast(
    within(
      notModeledPcts,
      nlcd <- factor(
        nlcd,
        levels= names( nlcdCovers),
        labels= nlcdCovers)),
    nlcd ~ gap, value= "pct"),
  digits=3,
  include.rownames= FALSE,
  colnames= c( "NLCD", "unprotected", "protected"),
  align= c( "l", "r", "r")) 
#+END_SRC


*** TODO Make a table of these results

#+begin_src R :results output org replace :exports results
suppressWarnings(
  ascii( 
    cast(
      statsNbcdCounty[, list(aldbMt = sum( aldb * ha)/ 10^6),
                      by= "state,gap"],
      formula= state ~ gap,
      value= "aldbMt",
      margins= TRUE,
      fun= sum),
    include.rownames= FALSE,
    digits= 0))
#+end_src

#+results:
#+BEGIN_ORG
| state | FALSE | TRUE | (all) |
|-------+-------+------+-------|
| 00    | 0     | 0    | 0     |
| 01    | 829   | 49   | 878   |
| 04    | 29    | 268  | 297   |
| 05    | 592   | 156  | 749   |
| 06    | 823   | 1287 | 2111  |
| 08    | 152   | 534  | 687   |
| 09    | 123   | 21   | 144   |
| 10    | 17    | 5    | 22    |
| 11    | 1     | 0    | 1     |
| 12    | 430   | 179  | 609   |
| 13    | 857   | 97   | 954   |
| 16    | 128   | 666  | 795   |
| 17    | 221   | 32   | 254   |
| 18    | 258   | 31   | 289   |
| 19    | 105   | 6    | 112   |
| 20    | 70    | 3    | 72    |
| 21    | 618   | 64   | 682   |
| 22    | 504   | 68   | 572   |
| 23    | 629   | 141  | 770   |
| 24    | 132   | 31   | 163   |
| 25    | 162   | 62   | 224   |
| 26    | 521   | 252  | 773   |
| 27    | 260   | 254  | 514   |
| 28    | 659   | 69   | 728   |
| 29    | 534   | 93   | 627   |
| 30    | 186   | 672  | 858   |
| 31    | 37    | 4    | 41    |
| 32    | 14    | 126  | 141   |
| 33    | 205   | 95   | 300   |
| 34    | 97    | 55   | 152   |
| 35    | 95    | 233  | 327   |
| 36    | 860   | 297  | 1157  |
| 37    | 812   | 154  | 965   |
| 38    | 20    | 7    | 27    |
| 39    | 444   | 47   | 492   |
| 40    | 285   | 33   | 318   |
| 41    | 606   | 1229 | 1835  |
| 42    | 828   | 270  | 1098  |
| 44    | 18    | 6    | 24    |
| 45    | 447   | 56   | 503   |
| 46    | 24    | 30   | 54    |
| 47    | 629   | 102  | 730   |
| 48    | 653   | 66   | 719   |
| 49    | 68    | 242  | 310   |
| 50    | 219   | 60   | 279   |
| 51    | 765   | 155  | 920   |
| 53    | 582   | 1007 | 1589  |
| 54    | 666   | 110  | 776   |
| 55    | 471   | 95   | 566   |
| 56    | 48    | 287  | 335   |
| (all) | 17736 | 9807 | 27543 |
#+END_ORG


*** calculate the grand total

#+begin_src R
  statsNbcdCounty[ I( nbcd), list( Gt= sum( aldb * ha) / 10^9)]
#+end_src


*** write out the results in long form

#+begin_src R

write.csv(
  statsNbcdCounty[, list( state, county, nlcd, gap, nbcd, aldb, ha, frac)],
  row.names= FALSE,
  file= "pad-us_nlcd/nbcdCountySerial.csv",
  quote= FALSE)

zip( "pad-us_nlcd.zip", "pad-us_nlcd/nbcdCountySerial.csv")

#+end_src

*** cross-tabulate the county data

#+begin_src R
  nbcdCountyAldb <- 
    data.table(
      cast(
        data= statsNbcdCounty,
        subset= nbcd,
        formula= state + county ~ gap + nlcd,
        value= "aldb"),
      key= "state,county")
  
  setnames(
    nbcdCountyAldb,
    colnames( nbcdCountyAldb),
    str_replace(
      str_replace(
        colnames( nbcdCountyAldb),
        "TRUE_", "yes"),
      "FALSE_", "no"))
  
  nbcdCountyAldbMeans <- 
    data.table(
      cast(
        data=
        statsNbcdCounty[
          I( nbcd),
          list( aldbAve= weighted.mean( aldb, ha, na.rm= TRUE)),
          by= c( "state", "county", "gap")],
        formula= state + county ~ gap,
        value= "aldbAve"),
      key= "state,county")
  
  setnames(
    nbcdCountyAldbMeans,
    c( "FALSE", "TRUE"),
    c( "noAll", "yesAll"))
  
  nbcdCountyGapFrac <-
    data.table(
      cast(
        data= statsNbcdCounty,
        formula= state + county ~ gap,
        value= "frac",
        fun.aggregate= sum,
        na.rm= TRUE),
      key= "state,county")
  
  setnames(
    nbcdCountyGapFrac,
    c( "FALSE", "TRUE"),
    c( "noAllFr", "yesAllFr"))
  
  nbcdCountyGapHa <-
    data.table(
      cast(
        data= statsNbcdCounty[, list( ha=sum( ha)),
          keyby= "state,county,gap,nbcd"],
        formula= state + county ~ gap + nbcd,
        value= "ha"),
      key= "state,county")
  
  setnames(
    nbcdCountyGapHa,
    c( "FALSE_FALSE", "FALSE_TRUE", "TRUE_FALSE", "TRUE_TRUE"),
    c( "noAllHaN", "noAllHa", "yesAllHaN", "yesAllHa"))
  
  nbcdCountyFrac <- 
    data.table(
      cast(
        data= statsNbcdCounty,
        subset= nbcd,
        formula= state + county ~ gap + nlcd,
        value= "frac"),
      key= "state,county")
  
  setnames(
    nbcdCountyFrac,
    colnames( nbcdCountyFrac)[ -(1:2)],
    paste(
      str_replace(
        str_replace(
          colnames( nbcdCountyFrac)[ -(1:2)],
          "TRUE_", "yes"),
        "FALSE_", "no"),
      "Fr", sep= ""))
  
  nbcdNullCountyFrac <- 
    data.table(
      cast(
        data= statsNbcdCounty,
        subset= !nbcd,
        formula= state + county ~ gap + nlcd,
        value= "frac"),
      key= "state,county")
  
  setnames(
    nbcdNullCountyFrac,
    colnames( nbcdNullCountyFrac)[ -(1:2)],
    paste(
      str_replace(
        str_replace(
          colnames( nbcdNullCountyFrac)[ -(1:2)],
          "TRUE_", "yes"),
        "FALSE_", "no"),
      "FrN", sep= ""))
  
  nbcdCountyHa <- 
    data.table(
      cast(
        data= statsNbcdCounty,
        subset= nbcd,
        formula= state + county ~ gap + nlcd,
        value= "ha",),
      key= "state,county")
  
  setnames(
    nbcdCountyHa,
    colnames( nbcdCountyHa)[ -(1:2)],
    paste(
      str_replace(
        str_replace(
          colnames( nbcdCountyHa)[ -(1:2)],
          "TRUE_", "yes"),
        "FALSE_", "no"),
      "Ha", sep= ""))
  
  nbcdNullCountyHa <- 
    data.table(
      cast(
        data= statsNbcdCounty,
        subset= !nbcd,
        formula= state + county ~ gap + nlcd,
        value= "ha",),
      key= "state,county")
  
  setnames(
    nbcdNullCountyHa,
    colnames( nbcdNullCountyHa)[ -(1:2)],
    paste(
      str_replace(
        str_replace(
          colnames( nbcdNullCountyHa)[ -(1:2)],
          "TRUE_", "yes"),
        "FALSE_", "no"),
      "HaN", sep= ""))
  
  
  nbcdCounty <-
    nbcdCountyAldb[ nbcdCountyAldbMeans]
  nbcdCounty <-
    nbcdCounty[ nbcdCountyGapFrac][ nbcdCountyGapHa]
  nbcdCounty <-
    nbcdCounty[ nbcdCountyFrac][ nbcdCountyHa]
  nbcdCounty <-
    nbcdCounty[ nbcdNullCountyFrac][ nbcdNullCountyHa]
  
  nbcdCounty <-
    nbcdCounty[, fips := paste( state, county, sep= "")]
  nbcdCounty <-
    nbcdCounty[, state := NULL][, county := NULL]
  setkey( nbcdCounty, fips)
  setcolorder( nbcdCounty, order( colnames( nbcdCounty)))
  
  nbcdCountyChar <-
    str_trim(
      format.df(
        nbcdCounty,
        cdec= sapply(
          colnames( nbcdCounty),
          function( x)
          ifelse(
            x == "fips", 0,
            ifelse(
              str_detect( x, "HaN?$"), 1,
              ifelse(
                str_detect( x, "FrN?$"), 3,
                1)))),
        numeric.dollar= FALSE,
        na.blank= TRUE))
  
  write.csv(
    nbcdCountyChar,
    row.names= FALSE,
    file= "pad-us_nlcd/nbcdCounty.csv",
    quote= FALSE)
  
  zip( "pad-us_nlcd.zip", "pad-us_nlcd/nbcdCounty.csv")
  
  options(useFancyQuotes = FALSE)
  cat(
    sapply(
      colnames( nbcdCounty),
      function( x) {
        dQuote(
          ifelse(
            x == "fips", "String(5)",
            ifelse(
              str_detect( x, "HaN?$"),
              "Real(10.1)",
              ifelse(
                str_detect( x, "FrN?$"),
                "Real(5.3)",
                "Real(5.1)"))))
      }),
    sep= ",",
    file= "pad-us_nlcd/nbcdCounty.csvt")
  options(useFancyQuotes = TRUE)
  
  ogr2ogr <-
    paste(
      "ogr2ogr -overwrite -progress -sql",
      sprintf(
        "\"select %s from cusaCountiesAea a",
        paste( colnames( nbcdCounty), collapse= ",")),
      "left join 'pad-us_nlcd/nbcdCounty.csv'.nbcdCounty b",
      "on a.GEOID10 = b.fips\"",
      "pad-us_nlcd/nbcdCounty.shp shp/cusaCountiesAea.shp")
  
  system( ogr2ogr)
  
  zip(
    "pad-us_nlcd.zip",
    list.files(
      path= "pad-us_nlcd",
      pattern= "^nbcdCounty\\.[a-z]{3}$",
      full.names= TRUE))
  
  
#+end_src


** Plots


#+begin_src R

library( ggplot2)
library( scales)

## totalTonnes <-
##   statsNbcdCounty[, list( aldb= sum( aldb * ha, na.rm= TRUE)),
##                   keyby= "gap,nlcd"]

## totalTonnes[, labelY := aldb/2 + c(0, cumsum( aldb)[-length( aldb)])]

## totalTonnes[, pct := round( aldb / sum( aldb) *100, 1)]
## totalTonnes[, label := ifelse( pct >= 0.5,
##                 sprintf( "%s, %3.1f%%", nlcd, pct), "")]

## totalTonnes[, label := sprintf( "%s, %d%%", nlcd, pct)]



totalTonnes <-
  statsNbcdCounty[, list( aldb= sum( aldb * ha, na.rm= TRUE),
                         ha= sum( ha, na.rm= TRUE)),
                  keyby= "nlcd,gap"]
totalTonnes <-
  totalTonnes[, aldbFrac := aldb / sum( aldb)]
totalTonnes <-
  totalTonnes[, haFrac := ha / sum( ha)]

nlcdColors <-
  c(
    "11" = "#5475A8",
    "12" = "#FFFFFF",
    "21" = "#E8D1D1",
    "22" = "#E29E8C",
    "23" = "#FF0000",
    "24" = "#B50000",
    "31" = "#D2CDC0",
    "41" = "#85C77E",
    "42" = "#38814E",
    "43" = "#D4E7B0",
    "52" = "#DCCA8F",
    "71" = "#FDE9AA",
    "81" = "#FBF65D",
    "82" = "#CA9146",
    "90" = "#C8E6F8",
    "95" = "#64B3D5")

nlcdCovers <-
  c(
    "11" = "water",
    "12" = "ice",
    "21" = "dev open",
    "22" = "dev low",
    "23" = "dev med",
    "24" = "dev high",
    "31" = "barren",
    "41" = "deciduous",
    "42" = "evergreen",
    "43" = "mixed",
    "52" = "shrub",
    "71" = "grass",
    "81" = "pasture",
    "82" = "crop",
    "90" = "woody wet",
    "95" = "wetland")

nlcdMeta <-
  data.table(
    nlcd= factor( names( nlcdColors)),
    color= nlcdColors,
    cover= nlcdCovers,
    key= "nlcd")

totalTonnes[, list( gap, nlcd,
                   frac = sprintf( "%5.4f", frac)),
            key= "nlcd"][ nlcdMeta]

totalTonnes <-
  totalTonnes[, nlcd := reorder( factor(nlcd), aldbFrac, max)]
setkey( totalTonnes, nlcd)

## with( totalTonnes, reorder( factor(nlcd), frac, max))


( massFracPlot <-
 ggplot(
   totalTonnes,
   aes(
     x= nlcd,
     y= aldbFrac,
     color= gap )) +
 geom_point(
   size= 4) +
 scale_x_discrete(
   name= "NLCD 2001 v1", ## ) +
   labels= nlcdMeta[ J( levels( totalTonnes$nlcd))][, cover]) +
 ylab( "Total mass fraction") +
 scale_color_manual(
   values= c( ## "#8C510A",
     "#D8B365", ## 0xF6E8C3; 0xC7EAE5;
     "#5AB4AC" ## "#01665E"
     )) + 
 coord_flip() +
 labs( colour= "Protected") +
 theme_bw())


## massFracPlot +
##   scale_y_log10(
##     limits= c(0.003, 0.35),
##     breaks= c( 0.01, 0.02, 0.03, 0.1, 0.2, 0.3), 
##     labels= percent)

## last_plot() +
##   scale_y_log10(
##     limits= c(0.003, 0.35),
##     breaks= c( 0.01, 0.02, 0.03, 0.1, 0.2, 0.3), 
##     labels= percent)

#+end_src
   

#+BEGIN_SRC R :results output graphics :exports both :results replace :file pad-us_nlcd/images/massFracPlot.png

suppressWarnings(
  massFracPlot %+%
  as.data.frame( totalTonnes[ aldbFrac > 0.003]) +
  scale_x_discrete(
    ## breaks= nlcdCovers[ as.character( totalTonnes[ frac > 0.003]$nlcd)],
    labels= nlcdCovers[ as.character( totalTonnes[ aldbFrac > 0.003]$nlcd),
      drop= TRUE]))

#+END_SRC

#+results:
[[file:pad-us_nlcd/images/massFracPlot.png]]

#+BEGIN_SRC R :results output graphics :exports both :results replace :file pad-us_nlcd/images/areaFracPlot.png

totalTonnes <-
  totalTonnes[, nlcd := reorder( factor(nlcd), haFrac, max)]
setkey( totalTonnes, nlcd)

( areaFracPlot <-
 ggplot(
   totalTonnes,
   aes(
     x= nlcd,
     y= haFrac,
     color= gap )) +
 geom_point(
   size= 4) +
 scale_x_discrete(
   name= "NLCD 2001 v1", ## ) +
   labels= nlcdMeta[ J( levels( totalTonnes$nlcd))][, cover]) +
 ylab( "Total area fraction") +
 scale_color_manual(
   values= c( ## "#8C510A",
     "#D8B365", ## 0xF6E8C3; 0xC7EAE5;
     "#5AB4AC" ## "#01665E"
     )) + 
 coord_flip() +
 labs( colour= "Protected") +
 theme_bw())

## suppressWarnings(
##   massFracPlot %+%
##   as.data.frame( totalTonnes) + ##[ haFrac > 0.003]) +
##  ylab( "Total area fraction") +
##   scale_x_discrete(
##     labels= nlcdCovers[ as.character( totalTonnes$nlcd), ##[ haFrac > 0.003]$nlcd),
##       drop= TRUE]))

#+END_SRC

#+results:
[[file:pad-us_nlcd/images/areaFracPlot.png]]

#+begin_src R

zip(
  "pad-us_nlcd.zip",
  list.files( "pad-us_nlcd/images", "png$", full.names=TRUE))
file.copy(
  from= list.files( "pad-us_nlcd/images", full.names= TRUE), 
  to=   "~/Dropbox/Carbon Inventory/images",
  overwrite= TRUE)

file.copy(
  from= "pad-us_nlcd.zip",
  to=   "~/Dropbox/Carbon Inventory",
  overwrite= TRUE)

#+end_src

*** TODO Work out a way to update changed files in the output .zip archive


* cross-tabulate HWSD soil texture classes by county

#+begin_src sh :session *shell*
  wget http://webarchive.iiasa.ac.at/Research/LUC/External-World-soil-database/HWSD_Data/HWSD_RASTER.zip
  mkdir data/HWSD_RASTER
  unzip HWSD_RASTER.zip -d data/HWSD_RASTER
  mv HWSD_RASTER.zip data
  wget http://webarchive.iiasa.ac.at/Research/LUC/External-World-soil-database/HWSD_Data/HWSD.mdb
  mv HWSD.mdb data
  mkdir data/HWSD
#+end_src

Extract the texture class columns and category labels from HWSD.mdb in
Windows.

Convert the topsoil relationship to GRASS reclassification rules.

#+begin_src R 
  library( doMC)
  ## library(foreach)
  ## library( iterators)
  
  registerDoMC()
  
  usdaTexClass <-
    read.csv( "data/HWSD/USDA_TEX_CLASS.csv")
  
  usdaTexClass <-
    within(
      usdaTexClass,
      T_USDA_TEX_CLASS <- ifelse(
        is.na( T_USDA_TEX_CLASS),
        "NULL",
        as.character( T_USDA_TEX_CLASS)))
  
  reclassRules <- foreach(
    d= iter( usdaTexClass, by= "row"),
    .combine= c) %dopar% {
      with( d, sprintf( "%d = %s", MU_GLOBAL, T_USDA_TEX_CLASS))
    }
  
  cat( reclassRules, file= "data/HWSD/T_USDA_TEX_CLASS.reclass", sep= "\n")  
#+end_src


Warp the HWSD raster into the cUSA GRASS location and generate the frequency statistics.

#+begin_src sh :session *grass*
  g.proj -fw > cUSA.wkt
  eval $(g.region -g)
  gdalwarp -s_srs EPSG:4326 -t_srs cUSA.wkt -te $w $s $e $n -srcnodata 0 -dstnodata 0 -of VRT data/HWSD_RASTER/hwsd.bil data/HWSD_RASTER/hwsd_cUSA_aea.vrt -overwrite
  r.in.gdal input=data/HWSD_RASTER/hwsd_cUSA_aea.vrt output=hwsd
  r.reclass  --overwrite input=hwsd output=hwsd_T_USDA_TEX_CLASS rules=data/HWSD/T_USDA_TEX_CLASS.reclass
  
  echo state,county,Nlcd01v1,hwsdTopTex,n > data/statsHwsdTopsoilTexture.csv \
      && r.stats -Nc input=states,counties,Nlcd01v1,hwsd_T_USDA_TEX_CLASS fs=, \
      >> data/statsHwsdTopsoilTexture.csv \
      2> data/statsHwsdTopsoilTexture.err &
  
#+end_src

#+begin_src R :session *R*
  library( data.table)
  
  stats <-
    read.csv( "data/statsHwsdTopsoilTexture.csv",
             na.strings= "*",
             col.names= c( "state","county","nlcd01v1","hwsdTopTex","n"),
             colClasses= c( "integer", "integer", "integer", "integer", "numeric"))
  
  stats <-
    within(
      stats,
      { ## levels( hwsdTopTex) <- c( levels( hwsdTopTex), "0")
        hwsdTopTex[ is.na( hwsdTopTex)] <- 0
      })
  
  dt <- data.table( stats)
  setkey( dt, state, county, nlcd01v1, hwsdTopTex)
  
  dt <- dt[, list(
    ha= sum(n) * 30^2 / 10^4),
           keyby= "state,county,nlcd01v1,hwsdTopTex"]
  
  
  
  ## wmCt <-
  ##   cast(
  ##     data= wm,
  ##     formula= cell ~ gap + nlcd,
  ##     ## fun.aggregate= sum,
  ##     ## margins= "grand_col",
  ##     value= "wm" )
  
  write.csv(
    format.df(
      dt[ !is.na( state)],
      cdec= c( rep( 0, 4), 2),
      numeric.dollar= FALSE,
      na.blank= TRUE),
    row.names= FALSE,
    file= "data/hwsdTopTexCounty.csv",
    quote= FALSE)
  
  zip( "data/hwsdTopTexCounty.zip", "data/hwsdTopTexCounty.csv")
  
#+end_src
